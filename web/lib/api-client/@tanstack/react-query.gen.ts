// This file is auto-generated by @hey-api/openapi-ts

import { type Options, delete_, findById, update, delete1, findById1, patch, update1, findAll, create, findAll1, create1, restore, restore1 } from '../sdk.gen';
import { type UseMutationOptions, type DefaultError, queryOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { DeleteData, FindByIdData, UpdateData, UpdateResponse, Delete1Data, FindById1Data, PatchData, PatchResponse, Update1Data, Update1Response, FindAllData, FindAllResponse, CreateData, CreateResponse, FindAll1Data, FindAll1Response, Create1Data, Create1Response, RestoreData, RestoreResponse, Restore1Data, Restore1Response } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export const deleteMutation = (options?: Partial<Options<DeleteData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await delete_({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const findByIdQueryKey = (options: Options<FindByIdData>) => createQueryKey('findById', options);

export const findByIdOptions = (options: Options<FindByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findByIdQueryKey(options)
    });
};

export const updateMutation = (options?: Partial<Options<UpdateData>>): UseMutationOptions<UpdateResponse, DefaultError, Options<UpdateData>> => {
    const mutationOptions: UseMutationOptions<UpdateResponse, DefaultError, Options<UpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await update({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const delete1Mutation = (options?: Partial<Options<Delete1Data>>): UseMutationOptions<unknown, DefaultError, Options<Delete1Data>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<Delete1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await delete1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findById1QueryKey = (options: Options<FindById1Data>) => createQueryKey('findById1', options);

export const findById1Options = (options: Options<FindById1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findById1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findById1QueryKey(options)
    });
};

export const patchMutation = (options?: Partial<Options<PatchData>>): UseMutationOptions<PatchResponse, DefaultError, Options<PatchData>> => {
    const mutationOptions: UseMutationOptions<PatchResponse, DefaultError, Options<PatchData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patch({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const update1Mutation = (options?: Partial<Options<Update1Data>>): UseMutationOptions<Update1Response, DefaultError, Options<Update1Data>> => {
    const mutationOptions: UseMutationOptions<Update1Response, DefaultError, Options<Update1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await update1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAllQueryKey = (options: Options<FindAllData>) => createQueryKey('findAll', options);

export const findAllOptions = (options: Options<FindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const findAllInfiniteQueryKey = (options: Options<FindAllData>): QueryKey<Options<FindAllData>> => createQueryKey('findAll', options, true);

export const findAllInfiniteOptions = (options: Options<FindAllData>) => {
    return infiniteQueryOptions<FindAllResponse, DefaultError, InfiniteData<FindAllResponse>, QueryKey<Options<FindAllData>>, number | Pick<QueryKey<Options<FindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<FindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    'pageable.page': pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await findAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllInfiniteQueryKey(options)
    });
};

export const createQueryKey2 = (options: Options<CreateData>) => createQueryKey('create', options);

export const createOptions = (options: Options<CreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await create({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createQueryKey2(options)
    });
};

export const createMutation = (options?: Partial<Options<CreateData>>): UseMutationOptions<CreateResponse, DefaultError, Options<CreateData>> => {
    const mutationOptions: UseMutationOptions<CreateResponse, DefaultError, Options<CreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await create({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAll1QueryKey = (options: Options<FindAll1Data>) => createQueryKey('findAll1', options);

export const findAll1Options = (options: Options<FindAll1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAll1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAll1QueryKey(options)
    });
};

export const findAll1InfiniteQueryKey = (options: Options<FindAll1Data>): QueryKey<Options<FindAll1Data>> => createQueryKey('findAll1', options, true);

export const findAll1InfiniteOptions = (options: Options<FindAll1Data>) => {
    return infiniteQueryOptions<FindAll1Response, DefaultError, InfiniteData<FindAll1Response>, QueryKey<Options<FindAll1Data>>, number | Pick<QueryKey<Options<FindAll1Data>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<FindAll1Data>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    'pageable.page': pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await findAll1({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAll1InfiniteQueryKey(options)
    });
};

export const create1QueryKey = (options: Options<Create1Data>) => createQueryKey('create1', options);

export const create1Options = (options: Options<Create1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await create1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: create1QueryKey(options)
    });
};

export const create1Mutation = (options?: Partial<Options<Create1Data>>): UseMutationOptions<Create1Response, DefaultError, Options<Create1Data>> => {
    const mutationOptions: UseMutationOptions<Create1Response, DefaultError, Options<Create1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await create1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restoreMutation = (options?: Partial<Options<RestoreData>>): UseMutationOptions<RestoreResponse, DefaultError, Options<RestoreData>> => {
    const mutationOptions: UseMutationOptions<RestoreResponse, DefaultError, Options<RestoreData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await restore({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restore1Mutation = (options?: Partial<Options<Restore1Data>>): UseMutationOptions<Restore1Response, DefaultError, Options<Restore1Data>> => {
    const mutationOptions: UseMutationOptions<Restore1Response, DefaultError, Options<Restore1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await restore1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};