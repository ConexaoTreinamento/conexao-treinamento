// This file is auto-generated by @hey-api/openapi-ts

import { type Options, softDeleteTrainerUser, findTrainerById, updateTrainerAndUser, delete_, findById, update, delete1, findById1, patch, update1, softDeleteAdministratorUser, findAdministratorById, patchAdministrator, updateAdministratorAndUser, getAllUsersSimple, createUser, findAllTrainers, createTrainerAndUser, findAll, create, findAll1, create1, logout, login, findAllAdministrators, createAdministratorAndUser, patch1, restore, restore1, test, findAllPaginated } from '../sdk.gen';
import { type UseMutationOptions, type DefaultError, queryOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { SoftDeleteTrainerUserData, FindTrainerByIdData, UpdateTrainerAndUserData, UpdateTrainerAndUserResponse, DeleteData, FindByIdData, UpdateData, UpdateResponse, Delete1Data, FindById1Data, PatchData, PatchResponse, Update1Data, Update1Response, SoftDeleteAdministratorUserData, FindAdministratorByIdData, PatchAdministratorData, PatchAdministratorResponse, UpdateAdministratorAndUserData, UpdateAdministratorAndUserResponse, GetAllUsersSimpleData, GetAllUsersSimpleResponse, CreateUserData, CreateUserResponse, FindAllTrainersData, CreateTrainerAndUserData, CreateTrainerAndUserResponse, FindAllData, FindAllResponse, CreateData, CreateResponse, FindAll1Data, FindAll1Response, Create1Data, Create1Response, LogoutData, LogoutResponse, LoginData, LoginResponse, FindAllAdministratorsData, CreateAdministratorAndUserData, CreateAdministratorAndUserResponse, Patch1Data, Patch1Response, RestoreData, RestoreResponse, Restore1Data, Restore1Response, TestData, FindAllPaginatedData, FindAllPaginatedResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export const softDeleteTrainerUserMutation = (options?: Partial<Options<SoftDeleteTrainerUserData>>): UseMutationOptions<unknown, DefaultError, Options<SoftDeleteTrainerUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<SoftDeleteTrainerUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await softDeleteTrainerUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const findTrainerByIdQueryKey = (options: Options<FindTrainerByIdData>) => createQueryKey('findTrainerById', options);

export const findTrainerByIdOptions = (options: Options<FindTrainerByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findTrainerById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findTrainerByIdQueryKey(options)
    });
};

export const updateTrainerAndUserMutation = (options?: Partial<Options<UpdateTrainerAndUserData>>): UseMutationOptions<UpdateTrainerAndUserResponse, DefaultError, Options<UpdateTrainerAndUserData>> => {
    const mutationOptions: UseMutationOptions<UpdateTrainerAndUserResponse, DefaultError, Options<UpdateTrainerAndUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTrainerAndUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMutation = (options?: Partial<Options<DeleteData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await delete_({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findByIdQueryKey = (options: Options<FindByIdData>) => createQueryKey('findById', options);

export const findByIdOptions = (options: Options<FindByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findByIdQueryKey(options)
    });
};

export const updateMutation = (options?: Partial<Options<UpdateData>>): UseMutationOptions<UpdateResponse, DefaultError, Options<UpdateData>> => {
    const mutationOptions: UseMutationOptions<UpdateResponse, DefaultError, Options<UpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await update({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const delete1Mutation = (options?: Partial<Options<Delete1Data>>): UseMutationOptions<unknown, DefaultError, Options<Delete1Data>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<Delete1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await delete1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findById1QueryKey = (options: Options<FindById1Data>) => createQueryKey('findById1', options);

export const findById1Options = (options: Options<FindById1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findById1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findById1QueryKey(options)
    });
};

export const patchMutation = (options?: Partial<Options<PatchData>>): UseMutationOptions<PatchResponse, DefaultError, Options<PatchData>> => {
    const mutationOptions: UseMutationOptions<PatchResponse, DefaultError, Options<PatchData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patch({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const update1Mutation = (options?: Partial<Options<Update1Data>>): UseMutationOptions<Update1Response, DefaultError, Options<Update1Data>> => {
    const mutationOptions: UseMutationOptions<Update1Response, DefaultError, Options<Update1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await update1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const softDeleteAdministratorUserMutation = (options?: Partial<Options<SoftDeleteAdministratorUserData>>): UseMutationOptions<unknown, DefaultError, Options<SoftDeleteAdministratorUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<SoftDeleteAdministratorUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await softDeleteAdministratorUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAdministratorByIdQueryKey = (options: Options<FindAdministratorByIdData>) => createQueryKey('findAdministratorById', options);

export const findAdministratorByIdOptions = (options: Options<FindAdministratorByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAdministratorById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAdministratorByIdQueryKey(options)
    });
};

export const patchAdministratorMutation = (options?: Partial<Options<PatchAdministratorData>>): UseMutationOptions<PatchAdministratorResponse, DefaultError, Options<PatchAdministratorData>> => {
    const mutationOptions: UseMutationOptions<PatchAdministratorResponse, DefaultError, Options<PatchAdministratorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patchAdministrator({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateAdministratorAndUserMutation = (options?: Partial<Options<UpdateAdministratorAndUserData>>): UseMutationOptions<UpdateAdministratorAndUserResponse, DefaultError, Options<UpdateAdministratorAndUserData>> => {
    const mutationOptions: UseMutationOptions<UpdateAdministratorAndUserResponse, DefaultError, Options<UpdateAdministratorAndUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateAdministratorAndUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllUsersSimpleQueryKey = (options: Options<GetAllUsersSimpleData>) => createQueryKey('getAllUsersSimple', options);

export const getAllUsersSimpleOptions = (options: Options<GetAllUsersSimpleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllUsersSimple({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUsersSimpleQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getAllUsersSimpleInfiniteQueryKey = (options: Options<GetAllUsersSimpleData>): QueryKey<Options<GetAllUsersSimpleData>> => createQueryKey('getAllUsersSimple', options, true);

export const getAllUsersSimpleInfiniteOptions = (options: Options<GetAllUsersSimpleData>) => {
    return infiniteQueryOptions<GetAllUsersSimpleResponse, DefaultError, InfiniteData<GetAllUsersSimpleResponse>, QueryKey<Options<GetAllUsersSimpleData>>, number | Pick<QueryKey<Options<GetAllUsersSimpleData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllUsersSimpleData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    'pageable.page': pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllUsersSimple({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUsersSimpleInfiniteQueryKey(options)
    });
};

export const createUserQueryKey = (options: Options<CreateUserData>) => createQueryKey('createUser', options);

export const createUserOptions = (options: Options<CreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createUserQueryKey(options)
    });
};

export const createUserMutation = (options?: Partial<Options<CreateUserData>>): UseMutationOptions<CreateUserResponse, DefaultError, Options<CreateUserData>> => {
    const mutationOptions: UseMutationOptions<CreateUserResponse, DefaultError, Options<CreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAllTrainersQueryKey = (options?: Options<FindAllTrainersData>) => createQueryKey('findAllTrainers', options);

export const findAllTrainersOptions = (options?: Options<FindAllTrainersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAllTrainers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllTrainersQueryKey(options)
    });
};

export const createTrainerAndUserQueryKey = (options: Options<CreateTrainerAndUserData>) => createQueryKey('createTrainerAndUser', options);

export const createTrainerAndUserOptions = (options: Options<CreateTrainerAndUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTrainerAndUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTrainerAndUserQueryKey(options)
    });
};

export const createTrainerAndUserMutation = (options?: Partial<Options<CreateTrainerAndUserData>>): UseMutationOptions<CreateTrainerAndUserResponse, DefaultError, Options<CreateTrainerAndUserData>> => {
    const mutationOptions: UseMutationOptions<CreateTrainerAndUserResponse, DefaultError, Options<CreateTrainerAndUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTrainerAndUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAllQueryKey = (options: Options<FindAllData>) => createQueryKey('findAll', options);

export const findAllOptions = (options: Options<FindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllQueryKey(options)
    });
};

export const findAllInfiniteQueryKey = (options: Options<FindAllData>): QueryKey<Options<FindAllData>> => createQueryKey('findAll', options, true);

export const findAllInfiniteOptions = (options: Options<FindAllData>) => {
    return infiniteQueryOptions<FindAllResponse, DefaultError, InfiniteData<FindAllResponse>, QueryKey<Options<FindAllData>>, number | Pick<QueryKey<Options<FindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<FindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    'pageable.page': pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await findAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllInfiniteQueryKey(options)
    });
};

export const createQueryKey2 = (options: Options<CreateData>) => createQueryKey('create', options);

export const createOptions = (options: Options<CreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await create({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createQueryKey2(options)
    });
};

export const createMutation = (options?: Partial<Options<CreateData>>): UseMutationOptions<CreateResponse, DefaultError, Options<CreateData>> => {
    const mutationOptions: UseMutationOptions<CreateResponse, DefaultError, Options<CreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await create({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAll1QueryKey = (options: Options<FindAll1Data>) => createQueryKey('findAll1', options);

export const findAll1Options = (options: Options<FindAll1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAll1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAll1QueryKey(options)
    });
};

export const findAll1InfiniteQueryKey = (options: Options<FindAll1Data>): QueryKey<Options<FindAll1Data>> => createQueryKey('findAll1', options, true);

export const findAll1InfiniteOptions = (options: Options<FindAll1Data>) => {
    return infiniteQueryOptions<FindAll1Response, DefaultError, InfiniteData<FindAll1Response>, QueryKey<Options<FindAll1Data>>, number | Pick<QueryKey<Options<FindAll1Data>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<FindAll1Data>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    'pageable.page': pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await findAll1({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAll1InfiniteQueryKey(options)
    });
};

export const create1QueryKey = (options: Options<Create1Data>) => createQueryKey('create1', options);

export const create1Options = (options: Options<Create1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await create1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: create1QueryKey(options)
    });
};

export const create1Mutation = (options?: Partial<Options<Create1Data>>): UseMutationOptions<Create1Response, DefaultError, Options<Create1Data>> => {
    const mutationOptions: UseMutationOptions<Create1Response, DefaultError, Options<Create1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await create1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutQueryKey = (options?: Options<LogoutData>) => createQueryKey('logout', options);

export const logoutOptions = (options?: Options<LogoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await logout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: logoutQueryKey(options)
    });
};

export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await logout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginQueryKey = (options: Options<LoginData>) => createQueryKey('login', options);

export const loginOptions = (options: Options<LoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await login({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginQueryKey(options)
    });
};

export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, DefaultError, Options<LoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await login({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findAllAdministratorsQueryKey = (options?: Options<FindAllAdministratorsData>) => createQueryKey('findAllAdministrators', options);

export const findAllAdministratorsOptions = (options?: Options<FindAllAdministratorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAllAdministrators({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllAdministratorsQueryKey(options)
    });
};

export const createAdministratorAndUserQueryKey = (options: Options<CreateAdministratorAndUserData>) => createQueryKey('createAdministratorAndUser', options);

export const createAdministratorAndUserOptions = (options: Options<CreateAdministratorAndUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAdministratorAndUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAdministratorAndUserQueryKey(options)
    });
};

export const createAdministratorAndUserMutation = (options?: Partial<Options<CreateAdministratorAndUserData>>): UseMutationOptions<CreateAdministratorAndUserResponse, DefaultError, Options<CreateAdministratorAndUserData>> => {
    const mutationOptions: UseMutationOptions<CreateAdministratorAndUserResponse, DefaultError, Options<CreateAdministratorAndUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAdministratorAndUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patch1Mutation = (options?: Partial<Options<Patch1Data>>): UseMutationOptions<Patch1Response, DefaultError, Options<Patch1Data>> => {
    const mutationOptions: UseMutationOptions<Patch1Response, DefaultError, Options<Patch1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patch1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restoreMutation = (options?: Partial<Options<RestoreData>>): UseMutationOptions<RestoreResponse, DefaultError, Options<RestoreData>> => {
    const mutationOptions: UseMutationOptions<RestoreResponse, DefaultError, Options<RestoreData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await restore({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const restore1Mutation = (options?: Partial<Options<Restore1Data>>): UseMutationOptions<Restore1Response, DefaultError, Options<Restore1Data>> => {
    const mutationOptions: UseMutationOptions<Restore1Response, DefaultError, Options<Restore1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await restore1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const testQueryKey = (options?: Options<TestData>) => createQueryKey('test', options);

export const testOptions = (options?: Options<TestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await test({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testQueryKey(options)
    });
};

export const findAllPaginatedQueryKey = (options: Options<FindAllPaginatedData>) => createQueryKey('findAllPaginated', options);

export const findAllPaginatedOptions = (options: Options<FindAllPaginatedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findAllPaginated({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllPaginatedQueryKey(options)
    });
};

export const findAllPaginatedInfiniteQueryKey = (options: Options<FindAllPaginatedData>): QueryKey<Options<FindAllPaginatedData>> => createQueryKey('findAllPaginated', options, true);

export const findAllPaginatedInfiniteOptions = (options: Options<FindAllPaginatedData>) => {
    return infiniteQueryOptions<FindAllPaginatedResponse, DefaultError, InfiniteData<FindAllPaginatedResponse>, QueryKey<Options<FindAllPaginatedData>>, number | Pick<QueryKey<Options<FindAllPaginatedData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<FindAllPaginatedData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    'pageable.page': pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await findAllPaginated({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findAllPaginatedInfiniteQueryKey(options)
    });
};