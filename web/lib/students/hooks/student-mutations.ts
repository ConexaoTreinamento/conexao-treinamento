import {useMutation, UseMutationOptions, useQueryClient} from "@tanstack/react-query";
import {
  createStudentMutation,
  deleteStudentMutation, findStudentByIdOptions,
  restoreStudentMutation,
  updateStudentMutation
} from "@/lib/api-client/@tanstack/react-query.gen";
import {apiClient} from "@/lib/client";
import type {Options, StudentResponseDto, UpdateStudentData} from "@/lib/api-client";

/**
 * Hooks that wrap generated mutation factories and add onSuccess invalidations
 * for the students list (findAll).
 *
 * These avoid editing autogenerated files and centralize invalidation logic.
 */

export const useCreateStudent = () => {
  const queryClient = useQueryClient();
  const base = createStudentMutation();
  const baseOnSuccess = base.onSuccess;

  return useMutation({
    ...base,
    onSuccess: async (data, variables, context) => {
      try {
        if (baseOnSuccess) {
          try {
            await baseOnSuccess(data, variables, context);
          } catch {
            // Best-effort: preserve base behaviour even if hook consumer swallows errors
          }
        }
      } catch {
        // ignore
      }

      await queryClient.invalidateQueries({
        predicate: (q) => Array.isArray(q.queryKey) && q.queryKey[0]?._id === "findAllStudents",
      });
    },
  });
};

export const useUpdateStudent = (options: UseMutationOptions<StudentResponseDto, Error, Options<UpdateStudentData>>) => {
  const queryClient = useQueryClient();
  const base = updateStudentMutation();
  const baseOnSuccess = base.onSuccess;

  return useMutation({
    ...base,
    ...options,
    onSuccess: async (data, variables, context) => {
      if (baseOnSuccess) {
        try {
          await baseOnSuccess(data, variables, context);
        } catch {
          // ignore
        }
      }

      if (options.onSuccess) {
        try {
          await options.onSuccess(data, variables, context);
        } catch {
          // ignore
        }
      }
      // Invalidate the students list
      await Promise.all([queryClient.invalidateQueries({
        predicate: (q) => Array.isArray(q.queryKey) && q.queryKey[0]?._id === 'findAllStudents'
      }),
        // Invalidate the specific cached student (findById) so the details refresh
        queryClient.invalidateQueries({
          queryKey: findStudentByIdOptions({path: {id: variables.path.id ?? ""}, client: apiClient}).queryKey
        })])
    }
  });
};

export const useDeleteStudent = () => {
  const queryClient = useQueryClient();
  const base = deleteStudentMutation();
  const baseOnSuccess = base.onSuccess;

  return useMutation({
    ...base,
    onSuccess: async (data, variables, context) => {
      if (baseOnSuccess) {
        try {
          await baseOnSuccess(data, variables, context);
        } catch {
          // ignore
        }
      }
      await queryClient.invalidateQueries({
        predicate: (q) => Array.isArray(q.queryKey) && q.queryKey[0]?._id === "findAllStudents",
      });
    },
  });
};

export const useRestoreStudent = () => {
  const queryClient = useQueryClient();
  const base = restoreStudentMutation();
  const baseOnSuccess = base.onSuccess;

  return useMutation({
    ...base,
    onSuccess: async (data, variables, context) => {
      if (baseOnSuccess) {
        try {
          await baseOnSuccess(data, variables, context);
        } catch {
          // ignore
        }
      }
      await queryClient.invalidateQueries({
        predicate: (q) => Array.isArray(q.queryKey) && q.queryKey[0]?._id === "findAllStudents",
      });
    },
  });
};
